// Code generated by candi v1.4.0.

package repository

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	"monorepo/services/master-service/internal/modules/apps/domain"
	shareddomain "monorepo/services/master-service/pkg/shared/domain"

	"pkg.agungdp.dev/candi/candihelper"
	"pkg.agungdp.dev/candi/candishared"
	"pkg.agungdp.dev/candi/tracer"
)

type permissionRepoMongo struct {
	readDB, writeDB *mongo.Database
	collection      string
}

// NewPermissionRepoMongo mongo repo constructor
func NewPermissionRepoMongo(readDB, writeDB *mongo.Database) PermissionRepository {
	return &permissionRepoMongo{
		readDB, writeDB, "apps_permissions",
	}
}

func (r *permissionRepoMongo) FetchAll(ctx context.Context, filter domain.FilterPermission) (data []shareddomain.Permission, err error) {
	trace := tracer.StartTrace(ctx, "PermissionRepoMongo:FetchAll")
	defer trace.Finish()
	ctx = trace.Context()
	defer func() { trace.SetError(err); tracer.Log(ctx, "results", data) }()

	findOptions := options.Find()
	if len(filter.OrderBy) > 0 {
		findOptions.SetSort(filter.OrderBy)
	}

	where := bson.M{}
	if filter.AppID != "" {
		where["appsId"] = filter.AppID
	}
	if len(filter.PermissionIDs) > 0 {
		where["_id"] = bson.M{
			"$in": filter.PermissionIDs,
		}
	}
	if len(filter.Codes) > 0 {
		where["code"] = bson.M{
			"$in": filter.Codes,
		}
	}

	if !filter.ShowAll {
		findOptions.SetLimit(int64(filter.Limit))
		findOptions.SetSkip(int64(filter.Offset))
	}
	trace.SetTag("query", where)

	cur, err := r.readDB.Collection(r.collection).Find(ctx, where, findOptions)
	if err != nil {
		return nil, err
	}
	defer cur.Close(ctx)

	for cur.Next(ctx) {
		var app shareddomain.Permission
		err := cur.Decode(&app)
		if err != nil {
			return data, err
		}
		app.CreatedAt = app.CreatedAtDB.Format(time.RFC3339)
		app.ModifiedAt = app.ModifiedAtDB.Format(time.RFC3339)
		data = append(data, app)
	}

	return
}

func (r *permissionRepoMongo) Count(ctx context.Context, filter candishared.Filter) int64 {
	trace := tracer.StartTrace(ctx, "PermissionRepoMongo:Count")
	defer trace.Finish()

	count, err := r.readDB.Collection(r.collection).CountDocuments(trace.Context(), bson.M{})
	trace.SetError(err)
	return count
}

func (r *permissionRepoMongo) GroupByAppsID(ctx context.Context, appsID ...string) (groups map[string][]shareddomain.Permission) {
	trace := tracer.StartTrace(ctx, "PermissionRepoMongo:FetchAll")
	defer trace.Finish()
	ctx = trace.Context()

	groups = make(map[string][]shareddomain.Permission)
	where := bson.M{
		"appsId": bson.M{
			"$in": appsID,
		},
	}
	cur, err := r.readDB.Collection(r.collection).Find(ctx, where)
	if err != nil {
		trace.SetError(err)
		return
	}
	defer cur.Close(ctx)

	for cur.Next(ctx) {
		var ep shareddomain.Permission
		err := cur.Decode(&ep)
		if err != nil {
			trace.SetError(err)
			return
		}
		groups[ep.AppsID] = append(groups[ep.AppsID], ep)
	}

	return
}

func (r *permissionRepoMongo) GroupByParentID(ctx context.Context, parentIDs ...string) (groups map[string][]shareddomain.Permission) {
	trace := tracer.StartTrace(ctx, "PermissionRepoMongo:GroupByParentID")
	defer trace.Finish()
	ctx = trace.Context()

	groups = make(map[string][]shareddomain.Permission)
	where := bson.M{
		"parentId": bson.M{
			"$in": parentIDs,
		},
	}
	cur, err := r.readDB.Collection(r.collection).Find(ctx, where)
	if err != nil {
		trace.SetError(err)
		return
	}
	defer cur.Close(ctx)

	for cur.Next(ctx) {
		var ep shareddomain.Permission
		err := cur.Decode(&ep)
		if err != nil {
			trace.SetError(err)
			return
		}
		groups[ep.ParentID] = append(groups[ep.ParentID], ep)
	}

	return
}

func (r *permissionRepoMongo) Find(ctx context.Context, data *shareddomain.Permission) (err error) {
	trace := tracer.StartTrace(ctx, "PermissionRepoMongo:Find")
	defer trace.Finish()
	defer func() { trace.SetError(err) }()
	ctx = trace.Context()

	bsonWhere := make(bson.M)
	if data.ID != "" {
		bsonWhere["_id"] = data.ID
	}
	if data.Code != "" {
		bsonWhere["code"] = data.Code
	}
	if data.AppsID != "" {
		bsonWhere["appsId"] = data.AppsID
	}
	trace.SetTag("query", bsonWhere)

	return r.readDB.Collection(r.collection).FindOne(ctx, bsonWhere).Decode(data)
}

func (r *permissionRepoMongo) Save(ctx context.Context, data *shareddomain.Permission) (err error) {
	trace := tracer.StartTrace(ctx, "PermissionRepoMongo:Count")
	defer trace.Finish()
	defer func() { trace.SetError(err) }()
	ctx = trace.Context()
	tracer.Log(ctx, "data", data)

	data.ModifiedAtDB = time.Now()
	if data.ID == "" {
		data.ID = primitive.NewObjectID().Hex()
		data.CreatedAtDB = time.Now()
		_, err = r.writeDB.Collection(r.collection).InsertOne(ctx, data)
	} else {
		opt := options.UpdateOptions{
			Upsert: candihelper.ToBoolPtr(true),
		}
		_, err = r.writeDB.Collection(r.collection).UpdateOne(ctx,
			bson.M{
				"_id": data.ID,
			},
			bson.M{
				"$set": data,
			}, &opt)
	}

	return
}
