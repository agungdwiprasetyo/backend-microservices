// Code generated by candi v1.4.0.

package usecase

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"monorepo/sdk"
	"monorepo/services/master-service/internal/modules/acl/domain"
	appsdomain "monorepo/services/master-service/internal/modules/apps/domain"
	shareddomain "monorepo/services/master-service/pkg/shared/domain"
	"monorepo/services/master-service/pkg/shared/repository"

	"pkg.agungdp.dev/candi/candishared"
	"pkg.agungdp.dev/candi/codebase/factory/dependency"
	"pkg.agungdp.dev/candi/codebase/interfaces"
	"pkg.agungdp.dev/candi/tracer"
)

type aclUsecaseImpl struct {
	cache     interfaces.Cache
	repoMongo *repository.RepoMongo
	sdk       sdk.SDK
	// commonUC  common.Usecase
}

// NewACLUsecase usecase impl constructor
func NewACLUsecase(deps dependency.Dependency) ACLUsecase {
	return &aclUsecaseImpl{
		cache:     deps.GetRedisPool().Cache(),
		repoMongo: repository.GetSharedRepoMongo(),
		sdk:       sdk.GetSDK(),
		// commonUC:  common.GetCommonUsecase(),
	}
}

func (uc *aclUsecaseImpl) Hello(ctx context.Context) (msg string) {
	trace := tracer.StartTrace(ctx, "AclUsecase:Hello")
	defer trace.Finish()
	ctx = trace.Context()

	return
}

func (uc *aclUsecaseImpl) SaveRole(ctx context.Context, payload domain.AddRoleRequest) (resp domain.AddRoleResponse, err error) {
	trace := tracer.StartTrace(ctx, "AclUsecase:SaveRole")
	defer trace.Finish()
	ctx = trace.Context()

	apps := shareddomain.Apps{Code: payload.AppsCode}
	if err := uc.repoMongo.AppsRepo.Find(ctx, &apps); err != nil {
		return resp, errors.New("Apps not found")
	}

	currentRole := shareddomain.Role{AppsID: apps.ID, Code: payload.Code}
	if err := uc.repoMongo.RoleRepo.Find(ctx, &currentRole); err != nil {
		currentRole.AppsID = apps.ID
		currentRole.Code = payload.Code
		currentRole.Name = payload.Name
	}

	currentRole.Permissions = map[string]string{}
	for _, permCode := range payload.Permissions {
		spl := strings.Split(permCode, ".")
		filterPermission := appsdomain.FilterPermission{
			Filter: candishared.Filter{ShowAll: true}, Codes: []string{spl[0], spl[len(spl)-1]},
		}
		permissions, err := uc.repoMongo.PermissionRepo.FetchAll(ctx, filterPermission)
		if err != nil || len(permissions) != len(filterPermission.Codes) {
			return resp, fmt.Errorf("Permission data '%s' not found", permCode)
		}
		for _, perm := range permissions {
			if perm.AppsID != apps.ID {
				return resp, fmt.Errorf("Permission code '%s' not match with apps '%s", permCode, apps.Code)
			}
			if perm.ParentID != "" {
				currentRole.Permissions[apps.Code+"."+permCode] = perm.ID
			} else {
				currentRole.Permissions[apps.Code+"."+perm.Code] = perm.ID
			}
		}
	}

	err = uc.repoMongo.RoleRepo.Save(ctx, &currentRole)

	resp.ID = currentRole.ID
	resp.AppsID = currentRole.AppsID
	resp.Code = currentRole.Code
	resp.Name = currentRole.Name
	return
}

func (uc *aclUsecaseImpl) GrantUser(ctx context.Context, payload domain.GrantUserRequest) (err error) {
	trace := tracer.StartTrace(ctx, "AclUsecase:GrantUser")
	defer trace.Finish()
	ctx = trace.Context()

	_, err = uc.sdk.UserService().GetMember(ctx, payload.UserID)
	if err != nil {
		return errors.New("user not found")
	}

	roleData := shareddomain.Role{ID: payload.RoleID}
	if err := uc.repoMongo.RoleRepo.Find(ctx, &roleData); err != nil {
		return errors.New("role not found")
	}

	// handle multiple acl role for one apps
	aclList, _ := uc.repoMongo.AclRepo.FindByUserID(ctx, payload.UserID)
	var roles []string
	aclMap := make(map[string]string, len(aclList))
	for _, acl := range aclList {
		roles = append(roles, acl.RoleID)
		aclMap[acl.RoleID] = acl.ID
	}

	aclData := shareddomain.ACL{
		UserID: payload.UserID, RoleID: payload.RoleID, AppsID: roleData.AppsID,
	}
	roleGroup := uc.repoMongo.RoleRepo.GroupByID(ctx, roles...)
	for _, role := range roleGroup {
		if role.AppsID == roleData.AppsID {
			aclData.ID = aclMap[role.ID]
			break
		}
	}

	return uc.repoMongo.AclRepo.Save(ctx, &aclData)
}

func (uc *aclUsecaseImpl) GetPermission(ctx context.Context, userID, appsID string) (data domain.CheckPermissionResponse, err error) {
	trace := tracer.StartTrace(ctx, "AclUsecase:GetPermission")
	defer trace.Finish()
	ctx = trace.Context()

	return
}

func (uc *aclUsecaseImpl) CheckPermission(ctx context.Context, payload domain.CheckPermissionRequest) (err error) {
	trace := tracer.StartTrace(ctx, "AclUsecase:CheckPermission")
	defer trace.Finish()
	ctx = trace.Context()
	trace.SetTag("userId", payload.UserID)

	acl, err := uc.repoMongo.AclRepo.FindByUserID(ctx, payload.UserID)
	if err != nil || len(acl) == 0 {
		return errors.New("ACL not found for this user")
	}

	var roles []string
	for _, a := range acl {
		roles = append(roles, a.RoleID)
	}

	roleGroup := uc.repoMongo.RoleRepo.GroupByID(ctx, roles...)
	hasAccess := false
	for _, role := range roleGroup {
		if _, ok := role.Permissions[payload.PermissionCode]; ok {
			hasAccess = true
			break
		}
	}

	if !hasAccess {
		return errors.New("Access not found")
	}

	return
}

func (uc *aclUsecaseImpl) GetAllRole(ctx context.Context, filter domain.RoleListFilter) (data []shareddomain.Role, meta candishared.Meta, err error) {
	trace := tracer.StartTrace(ctx, "AclUsecase:GetAllRole")
	defer trace.Finish()
	ctx = trace.Context()

	return
}
