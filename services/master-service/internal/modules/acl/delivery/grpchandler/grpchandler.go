// Code generated by candi v1.4.0.

package grpchandler

import (
	"context"

	proto "monorepo/sdk/master-service/proto/acl"
	"monorepo/services/master-service/internal/modules/acl/domain"
	"monorepo/services/master-service/internal/modules/acl/usecase"

	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"

	"pkg.agungdp.dev/candi/codebase/factory/types"
	"pkg.agungdp.dev/candi/codebase/interfaces"
	"pkg.agungdp.dev/candi/tracer"
)

// GRPCHandler rpc handler
type GRPCHandler struct {
	mw        interfaces.Middleware
	uc        usecase.ACLUsecase
	validator interfaces.Validator
}

// NewGRPCHandler func
func NewGRPCHandler(mw interfaces.Middleware, uc usecase.ACLUsecase, validator interfaces.Validator) *GRPCHandler {
	return &GRPCHandler{
		mw: mw, uc: uc, validator: validator,
	}
}

// Register grpc server
func (h *GRPCHandler) Register(server *grpc.Server, mwGroup *types.MiddlewareGroup) {
	proto.RegisterAclHandlerServer(server, h)

	// register middleware for method
	// mwGroup.AddProto(proto.File_acl_acl_proto, "CheckPermission", h.mw.GRPCBearerAuth)
}

// CheckPermission rpc method
func (h *GRPCHandler) CheckPermission(ctx context.Context, req *proto.CheckPermissionRequest) (*proto.CheckPermissionResponse, error) {
	trace := tracer.StartTrace(ctx, "AclDeliveryGRPC:CheckPermission")
	defer trace.Finish()
	ctx = trace.Context()

	err := h.uc.CheckPermission(ctx, domain.CheckPermissionRequest{
		UserID:         req.UserID,
		PermissionCode: req.PermissionCode,
	})
	if err != nil {
		return nil, grpc.Errorf(codes.PermissionDenied, err.Error())
	}

	return &proto.CheckPermissionResponse{
		IsAllowed: err == nil,
	}, nil
}
