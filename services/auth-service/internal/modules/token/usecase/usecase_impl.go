// Code generated by candi v1.3.1.

package usecase

import (
	"context"
	"crypto/rsa"
	"errors"
	"time"

	"monorepo/services/auth-service/internal/modules/token/domain"
	"monorepo/services/auth-service/pkg/shared/repository"

	jwt "github.com/dgrijalva/jwt-go"
	"pkg.agungdwiprasetyo.com/candi/candishared"
	"pkg.agungdwiprasetyo.com/candi/codebase/factory/dependency"
	"pkg.agungdwiprasetyo.com/candi/codebase/interfaces"
)

const (
	// TokenKey const
	TokenKey = "18608c7d-b319-0xc000165c80-0xc0000da000-11478e4e2650"
)

var (
	// ErrTokenFormat var
	ErrTokenFormat = errors.New("Invalid token format")
	// ErrTokenExpired var
	ErrTokenExpired = errors.New("Token is expired")
)

type tokenUsecaseImpl struct {
	cache interfaces.Cache

	repoMongo  *repository.RepoMongo
	publicKey  *rsa.PublicKey
	privateKey *rsa.PrivateKey
}

// NewTokenUsecase usecase impl constructor
func NewTokenUsecase(deps dependency.Dependency) TokenUsecase {
	return &tokenUsecaseImpl{
		cache:      deps.GetRedisPool().Cache(),
		repoMongo:  repository.GetSharedRepoMongo(),
		publicKey:  deps.GetKey().PublicKey(),
		privateKey: deps.GetKey().PrivateKey(),
	}
}

// Generate token
func (uc *tokenUsecaseImpl) Generate(ctx context.Context, payload *domain.Claim) <-chan candishared.Result {
	output := make(chan candishared.Result)

	go func() {
		defer close(output)

		now := time.Now()
		exp := now.Add(60 * time.Hour)

		var key interface{}
		var token = new(jwt.Token)
		if payload.Alg == domain.HS256 {
			token = jwt.New(jwt.SigningMethodHS256)
			key = []byte(TokenKey)
		} else {
			token = jwt.New(jwt.SigningMethodRS256)
			key = uc.privateKey
		}
		claims := jwt.MapClaims{
			"iss":  "agungdwiprasetyo.com",
			"exp":  exp.Unix(),
			"iat":  now.Unix(),
			"did":  payload.DeviceID,
			"aud":  payload.Audience,
			"jti":  payload.Id,
			"user": payload.User,
		}
		token.Claims = claims

		tokenString, err := token.SignedString(key)
		if err != nil {
			output <- candishared.Result{Error: err}
			return
		}

		output <- candishared.Result{Data: tokenString}
	}()

	return output
}

// Refresh token
func (uc *tokenUsecaseImpl) Refresh(ctx context.Context, token string) <-chan candishared.Result {
	output := make(chan candishared.Result)

	go func() {
		defer close(output)
	}()

	return output
}

// Validate token
func (uc *tokenUsecaseImpl) Validate(ctx context.Context, tokenString string) <-chan candishared.Result {
	output := make(chan candishared.Result)

	go func() {
		defer close(output)

		tokenParse, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
			checkAlg, _ := candishared.GetValueFromContext(ctx, candishared.ContextKey("tokenAlg")).(string)
			if checkAlg == domain.HS256 {
				return []byte(TokenKey), nil
			}
			return uc.publicKey, nil
		})

		var errToken error
		switch ve := err.(type) {
		case *jwt.ValidationError:
			if ve.Errors == jwt.ValidationErrorExpired {
				errToken = ErrTokenExpired
			} else {
				errToken = ErrTokenFormat
			}
		}

		if errToken != nil {
			output <- candishared.Result{Error: errToken}
			return
		}

		if !tokenParse.Valid {
			output <- candishared.Result{Error: ErrTokenFormat}
			return
		}

		mapClaims, _ := tokenParse.Claims.(jwt.MapClaims)

		var tokenClaim domain.Claim
		tokenClaim.DeviceID, _ = mapClaims["did"].(string)
		tokenClaim.Audience, _ = mapClaims["aud"].(string)
		tokenClaim.Id, _ = mapClaims["jti"].(string)
		exp, _ := mapClaims["exp"].(float64)
		tokenClaim.ExpiresAt = int64(exp)
		userData, _ := mapClaims["user"].(map[string]interface{})
		tokenClaim.User.ID, _ = userData["id"].(string)
		tokenClaim.User.Username, _ = userData["username"].(string)

		output <- candishared.Result{Data: &tokenClaim}
	}()

	return output
}

// Revoke token
func (uc *tokenUsecaseImpl) Revoke(ctx context.Context, token string) <-chan candishared.Result {
	output := make(chan candishared.Result)

	go func() {
		defer close(output)
	}()

	return output
}
